{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the unofficial live remote scripts docs. This is an attempt to document what i have learned while writing my custom user remote script for Ableton Live. This Documentation is intended to be written by the ableton live community to make it easier for users to write their own custom remote scripts.</p> <p>Special thanks to gabrielyshay for his article on how to make a control surface for Ableton  which truly helped me out on getting started with writing my own custom script and therefore this documentation.</p>"},{"location":"contribution/","title":"Contribution","text":"<p>This documentation is unofficial and created solely by digging through the decompiled python libraries for creating Custom Remote Scripts. Feel free to contribute by creating a PR to this documentation.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Before getting started, there are a few things to note.</p>"},{"location":"getting_started/#documentation-example-project","title":"Documentation Example Project","text":"<p>To elaborate the Remote Scripts API we will explain all the necessary parts by building an example remote control script for the BCR2000 which is a Midi Controller with 32 Encoders and 20 assignable Buttons.</p> <p>TODO decompiled bytecode</p> <p>TODO how to Setup</p> <p>TODO Tailing the logs</p>"},{"location":"api/listeners/","title":"Event Listeners","text":""},{"location":"api/live_object_model/","title":"The Live Object Model","text":""},{"location":"api/main_components/","title":"Remote Script API Main Components","text":""},{"location":"api/main_components/#__init__","title":"<code>__init__</code>","text":"<p>If you are new to python, you might have recognized, that within each directory in a python project, there is a <code>__init__.py</code> file. This file initializes a regular python package and everything within this file is executed when the package is imported.</p> <p>The entrypoint for every Custom Remote Script is the <code>create_instance</code> function within the <code>__init__</code> file. The function needs to return your custom implementation of the <code>ControlSurface</code>. The function has one call argument <code>c_instance</code> which I guess is an instance of some Custom Remote Script abstraction from the Live core which is written in C++.</p> <p>Live will (most probably) call this function whenever you select the remote script in the preferences or on application start if it has been selected previously.</p> <pre><code># __init__.py\n\nfrom ableton.v3.control_surface import ControlSurface\nfrom .bcr_2000 import CustomBCR2000\n\n\ndef create_instance(c_instance) -&gt; ControlSurface:\n    return CustomBCR2000(c_instance=c_instance)\n</code></pre> <p>Whenever the import of this file, or the call of the <code>create_instance</code> function errors, your remote script will not be available in Live.</p>"},{"location":"api/main_components/#elements","title":"<code>Elements</code>","text":""},{"location":"api/main_components/#controlsurfacespecification","title":"<code>ControlSurfaceSpecification</code>","text":"<p>The Specification is the base configuration of your Remote Control Script. To create your own <code>Specification</code> you inherit from the <code>ableton.v3.control_surface.ControlSurfaceSpecification</code> class and set the properties you want to configure.</p>"},{"location":"api/main_components/#properties","title":"Properties","text":"property python type description <code>elements_type</code> <code>Type[ElementsBase]</code> Subclass of <code>ableton.v3.control_surface.ElementsBase</code> for the definition of your hardware controls such as encoders, buttons etc. <code>create_mappings_function</code> <code>Callable[[ControlSurface], Dict[str, any]]</code> A function that maps the names of the hardware controls defined in the <code>elements_type</code> to the software controls of your components. <code>component_map</code> <code>Dict[str, Type[Component]]</code> A dictionary that maps component names to <code>ableton.v3.control_surface.Component</code> types. The defined components within this map will be loaded automatically and do not to be instantiated by your own. You can access them within your <code>ControlSurface</code> class via <code>self.component_map[\"name-of-the-component\"]</code> <pre><code># speficication.py\n\nfrom ableton.v3.control_surface import ControlSurfaceSpecification, ControlSurface, DeviceComponent\nfrom .elements import BCR2000Elements\n\n\ndef create_mappings(_: ControlSurface) -&gt; Dict[str, any]:\n    return {\n        \"Device\": {\n            \"parameter_controls\": \"device_controls\"\n        }\n    }\n\n\nclass BCR2000Specification(ControlSurfaceSpecification):\n    elements_type = BCR2000Elements\n    create_mappings_function = create_mappings\n    component_map = {\n        \"Device\": DeviceComponent\n    }\n</code></pre>"},{"location":"api/main_components/#controlsurface","title":"<code>ControlSurface</code>","text":"<p>The Control Surface represents your controller. Each control surface is instantiated once it is selected in Live. You need to inherit from this class.</p> <pre><code># bcr_2000.py\n\nfrom ableton.v3.control_surface import ControlSurface\n\n\nclass CustomBCR2000(ControlSurface):\n# TODO Override init and provide specification\n# log a message\n# setup function\n</code></pre>"},{"location":"api/main_components/#component","title":"<code>Component</code>","text":""}]}